
/**




**/

var Parser = require("./parser");


var Query = module.exports = function(str) {

  query = Parser.parse(str);

  // Store query information
  this.key = query.key || null;

  // Ensure we have a table!
  if (!query.table) throw new Error("Query must have a table");
  this.table = query.table;

  this.fields = query.fields || [];

  // Parse options and filters
  this.parseOptions(query.options);
  this.parseFilters(query.filters);

};



/**

  Parses query options, which currently consist of `sort` and `limit`.
  Attaches the results to the class object (e.g. this.sort, this.limit).

  @param {Array} options Array of {key, value} options.

**/

Query.prototype.parseOptions = function(options) {

  var key, val;

  // Walk through options. Each option is of format {key, value}
  for (var i = 0, n = options.length; i < n; i++) {

    key = options[i].key;
    val = options[i].value;

    switch (key) {
      case "sort":
      case "sortBy":

        // Add leading "+" if missing
        if ("+" !== val[0] && "-" !== val[0]) val = "+" + val;

        // Return all matches
        match = val.match(/([\+\-])([^\+\-]+)/g);

        // Set sorts (this will throw error if malformed, which we want)
        this.sort = new Array(match.length);
        for (var j = 0, m = match.length; j < m; j++) {
          this.sort[j] = { key : match[j].slice(1), order : ("-" === match[j][0]) ? "desc" : "asc" };
        }

        break;
      case "limit":
        this.limit = parseInt(val);
        if (isNaN(this.limit)) this.limit = val;
        break;
      default:
        throw new Error("Unknown option in query:", key);
    }
  }

};



/**

  Parses filters and attaches actionable Reverse Polish Notation to this.filters.

  There are two forms of steps: Operations and Statements.

  An Operation consists of an operator (&, |) and operands (array of statements).
  A Statement consists of a key, a comparator, and a value (e.g. test key = value).

  @param {Array} filters Array of Operations/Statements generated by parser.

**/

Query.prototype.parseFilters = function(filters) {

  // Initialize
  this.filters = [];

  // Start recursive calls
  this.parseFilter(filters || []);

  // Reverse (into Revere Polish Notation)
  this.filters = this.filters.reverse();

};


/**

  Recursive step that drives parseFilters.

  @param {Object} step An Operation or a Statement.

**/

Query.prototype.parseFilter = function(step) {

  // If there are no operands, this must be an execution statement
  if (!step.operands) {
    this.filters.push(step);
    return;
  }

  // Single operands don't require operators
  if (step.operands.length < 2)
    this.parseFilter(step.operands[0]);

  // Push to stack in format that will allow Reverse Polish Notation
  // Namely, we want + A + B + C D, which, when reversed yields D C + B + A +
  else {
    for (var i = 0, n = step.operands.length - 1; i < n; i++) {
      this.filters.push(step.operator);
      this.parseFilter(step.operands[i]);
    }
    this.parseFilter(step.operands[i]);
  }

};
